package algorithm.search_and_sort;

/*
    有一个整形数组 A，请设计一个复杂度为 O (n) 的算法，
    算出排序后相邻两数的最大差值。
    给定一个 int 数组 A 和 A 的大小 n，请返回最大的差值。
    保证数组元素多于 1 个。
 */

public class MaxGapDemo {

    public static void main(String[] args) {
        int[] arr = {9590, 5695, 4776, 5450, 9128, 2219, 4782, 5023, 3685, 54, 2688, 4716, 8175, 1012, 3079, 5574, 6336, 3755, 5328, 2925, 3825, 3443, 9253, 7427, 3809, 9360, 8809, 5885, 8944, 2048, 8170, 1285, 1223, 2186, 2969, 5342, 5076, 911, 391, 1950, 2480, 1264, 9795, 45, 1763, 9169, 7526, 6225, 5571, 5805, 9468, 9383, 6885, 1576, 9810, 6544, 853, 9628, 175, 4595, 5025, 8688, 9239, 975, 5370, 673, 9435, 5559, 205, 744, 2146, 2597, 987, 7727, 3116, 5843, 1575, 6252, 2245, 4205, 3481, 3600, 1910, 8912, 3824, 1333, 8392, 6311, 3504, 8379, 9636, 244, 5835, 1896, 4181, 5452, 617, 4850, 6326, 2381, 4524, 5502, 9970, 9919, 8138, 69, 5831, 7087, 416, 8547, 5568, 4658, 7418, 2703, 837, 9223, 7926, 5703, 3623, 7347, 8297, 5270, 9026, 1913, 6588, 4362, 6278, 2129, 422, 6819, 3828, 7056, 3926, 8088, 7424, 7823, 9408, 2836, 4629, 8770, 5793, 662, 269, 9958, 9569, 9321, 5095, 9075, 9883, 8858, 79, 7148, 6446, 2854, 8157, 9279, 6063, 696, 236, 7060, 8070, 3431, 854, 4811, 858, 2501, 9900, 6987, 5021, 6246, 8057, 3198, 2847, 2758, 4540, 5268, 7924, 6729, 8661, 9045, 8118, 6669, 5603, 5585, 9753, 8098, 2712, 6487, 2500, 7702, 7103, 9492, 7662, 7623, 671, 7095, 2214, 7512, 4991, 1712, 5238, 1874, 8203, 6442, 6785, 158, 1343, 2574, 415, 6316, 8487, 3159, 2151, 5176, 3250, 1572, 7555, 188, 3098, 5595, 7337, 5693, 2928, 5179, 1251, 8417, 1235, 7807, 1733, 4618, 1664, 5007, 1589, 857, 4440, 4041, 4652, 6515, 1284, 6564, 8916, 9961, 7111, 4749, 6903, 9085, 4064, 6868, 1399, 9619, 4977, 4505, 5226, 7264, 5149, 9909, 5065, 1164, 3057, 9360, 5084, 336, 4994, 9715, 7446, 8395, 7324, 6319, 9460, 464, 2259, 2183, 2365, 9115, 7768, 8529, 4445, 2349, 3414, 5595, 2768, 9367, 9366, 8874, 2052, 8875, 8481, 8528, 8631, 874, 3344, 2434, 2454, 4231, 5793, 5388, 9261, 6075, 4236, 904, 3433, 7027, 7065, 3230, 8830, 6011, 830, 9467, 8512, 3098, 6858, 7226, 228, 4202, 7216, 2414, 9676, 8528, 348, 7004, 8965, 7050, 4045, 5379, 9432, 6224, 8699, 3739, 9822, 1867, 1486, 9600, 6690, 930, 2807, 7584, 691, 8949, 118, 9720, 1286, 3489, 5623, 1596, 8657, 7902, 63, 5136, 4851, 1111, 5665, 4060, 9291, 5156, 4845, 5331, 8544, 6089, 6574, 5618, 4406, 6850, 939, 5107, 9179, 2240, 1964, 7938, 1021, 6793, 8417, 1102, 2565, 8379, 703, 7768, 8183, 5518, 9335, 3839, 1258, 8463, 589, 5209, 2419, 9296, 3570, 9351, 2648, 4734, 6006, 306, 5720, 1112, 8299, 1619, 68, 1986, 279, 7750, 9680, 9980, 5407, 7364, 1275, 4493, 3118, 4026, 2670, 2072, 978, 9299, 3314, 2361, 4415, 9950, 8859, 5163, 817, 4150, 7022, 891, 4788, 7405, 9288, 5527, 3923};
        MaxGapDemo maxGapDemo = new MaxGapDemo();
        System.out.println(maxGapDemo.maxGap(arr, arr.length));
    }

    public int maxGap(int[] arr, int n) {
        if (arr == null || n < 2) {
            return 0;
        }
        int min = Integer.MAX_VALUE;
        int max = Integer.MIN_VALUE;
        int maxGap = 0;
        for (int i = 0; i < n; i++) {
            max = Math.max(arr[i], max);
            min = Math.min(arr[i], min);
        }

        int range = max - min;
        if (0 == range) return 0;

        boolean[] hasNum = new boolean[n + 1];
        int[] maxs = new int[n + 1];
        int[] mins = new int[n + 1];

        for (int i = 0; i < n; i++) {
            // 使用long类型是为了防止相乘时溢出
            int bid = (int) ((long) (arr[i] - min) * (long) n / (long) range);
            mins[bid] = hasNum[bid] ? Math.min(mins[bid], arr[i]) : arr[i];
            maxs[bid] = hasNum[bid] ? Math.max(maxs[bid], arr[i]) : arr[i];
            hasNum[bid] = true;
        }

        int index = 0, lastMax = 0;

        while (index <= n) {
            if (hasNum[index++]) {          // 第一个非空桶
                lastMax = maxs[index - 1];
                break;
            }
        }

        for (; index <= n; index++) {
            if (hasNum[index]) {
                maxGap = Math.max(maxGap, mins[index] - lastMax);
                lastMax = maxs[index];
            }
        }

        return maxGap;
    }
}
